{
  "version": 3,
  "sources": ["../src/world-params.js", "../src/index-coord-helper.js", "../src/mycor-params.js", "../src/soil-activities.js", "../src/sky-activities.js", "../src/nutri-grid.js", "../src/style-helper.js", "../src/hose.js", "../src/single-seed.js", "../src/page-effects.js", "../src/main.js"],
  "sourcesContent": ["import \"./style/main.css\";\n\nmodule.exports = {\n   WIDTH: 95,\n   SKY_HEIGHT: 15,\n   SOIL_HEIGHT: 50,\n   HEIGHT: 65,\n   MYCOR_NUM: 2,\n   MYCOR_RADIUS: 5,\n   MYCOR_MIN_RADIUS: 1,\n   LOWEST_STARTING_NUTRI: 25,    // lowest nutri value to be distributed to soil cells \n   LOW_NUTRI: 6,                 // indicating soil has low nutri \n   MAX_NUTRI: 32,                // highest nutri value to be initially distributed \n   FLOOD_THRESHOLD: 60,\n   WATER_NUTRI_VAL: 20,          // amount of nutrients a drop of water can deliver\n   ROOT_LEN_FOR_PLANT: 10,       // how much root1 must grow before plant starts sprouting \n   MAX_ROOT_LEN: 200,             // maximum length that a root can grow (init max value)\n   ROOT_MULTIPLIER: 8,           // multiply by stem length to figure out max root growth\n   ROOT_GROWTH_RATE: 30,         // root and plant grows 1 cell every 30 mins, nutrient reduces by .5 every 30 mins \n   frame: document.querySelector('.frame')\n};\n\n\n// keeping the difference between LOWEST STARTING NUTRI and MAXI NUETRI at 7 \n// results in prettily growing roots c:", "// relates cell indices to x, y positions \n\nlet world = require('./world-params.js');\nlet {WIDTH, SOIL_HEIGHT, HEIGHT, frame} = world;\n\n\nfunction coordY(cell) {\n   // return the Y position of a cell based on its id\n   let y;\n   let id = Number(cell.id);\n   for (i=0; i<HEIGHT + 1; i++) {\n      if (id < i * WIDTH && id >= (i-1) * WIDTH) {\n         y = i-1;\n      }\n   }\n   if (y === undefined) { // why is 'undefined' returned instead of 0?\n      y = 0;\n   } \n   return y\n}\n\nfunction coordX(cell) {\n   // return the X position of a cell based on its id\n   let x;\n   let id = Number(cell.id);\n   if (coordY(cell) == 0) {\n      x = id;\n   } else if (coordY(cell) > 0) {\n      x = id - WIDTH * coordY(cell);\n   }\n   if (x == undefined) { return 0; }\n   else { return x; }\n}\n\nfunction coordToIndex(lst) {\n   // given an array of [x,y] coordinates from a 2-D list,\n   // return the associated index value in its 1-D list\n   return lst[1] * WIDTH + lst[0]\n}\n\n\nexport {\n   coordY,\n   coordX,\n   coordToIndex\n}", "module.exports = {\n   O_COEFF: 0, // Weights the contribution of the original velocity on the previous step\n   A_COEFF: 1.0, // Weights the contribution of the alignment rule (boids go in the same dir)\n   C_COEFF: 1.0, // Weights the contribution of the cohesion rule (boids gather in the clumps)\n   S_COEFF: 2.0, // Weights the contribution of the separation rule (boids don't want to collide).\n   R_COEFF: 0.5, // Weights a small random contribution to the velocity.\n}", "// This file contains all the code for all activies that happen in the soil\n\n\n/*\nTO DO's: \n- fix mycor so they don't all disappear all at once \n- design mycellium + root interactions \n*/\n\n\n// ========\n// set up\n// ========\n\nimport \"./style/main.css\";\nimport {coordY, coordX, coordToIndex} from './index-coord-helper.js';\n\nlet worldParams = require('./world-params.js');\nlet {\n   WIDTH, \n   SOIL_HEIGHT, \n   HEIGHT, \n   MYCOR_NUM,\n   MYCOR_RADIUS,\n   MYCOR_MIN_RADIUS,\n   LOWEST_STARTING_NUTRI, \n   MAX_NUTRI, \n   frame} = worldParams;\n\n/*\n// now included in worldParams\nconst MYCOR_NUM = 1;\nconst MYCOR_RADIUS = 5;\nconst MYCOR_MIN_RADIUS = 1;\n*/\n\nlet soil = [];\nlet soilInfo = [];\nlet mycorInfo = [];\n\nclass soilCell {\n   constructor(state, nutri, id, organism) {\n      this.state = state;  // soil, h_root, v_root, root1\n      this.nutri = nutri;  // nutrient level in specific soil cell\n      this.id = id;        // soil id\n      this.organism = organism;    // any organism populating the cell\n   }\n}\n\nclass mycor {\n   constructor(vel, separation, radius, id) {\n      this.vel = vel;\n      this.separation = separation;\n      this.radius = radius;\n      this.id = id;\n   }\n}\n\n\n// =======================\n// env and storage set up\n// =======================\n\nfunction createSoil() {\n   let stotal = WIDTH * SOIL_HEIGHT;\n   for(let i=0; i < stotal; i++) {\n      const cell = document.createElement('div');\n      cell.classList.add(\"soil\");\n      cell.setAttribute('id',i);\n      frame.appendChild(cell);\n      soil.push(cell);\n   }\n   for (let i = 0; i < WIDTH; i++) {\n      soil[i].classList.add(\"organic\");\n   }\n   for (let i = WIDTH; i < stotal / 2 - WIDTH; i++){\n      soil[i].classList.add(\"topsoil\");\n   }\n   for (let i = stotal / 2 - WIDTH; i < stotal; i++) {\n      soil[i].classList.add(\"subsoil\");\n   }\n}\n\nfunction loadSoilInfo() {\n   for (let i = 0; i < WIDTH; i++) {\n      soilInfo.push(new soilCell(\n         soil[i].className, \n         Math.floor(Math.random() * (MAX_NUTRI-LOWEST_STARTING_NUTRI) + LOWEST_STARTING_NUTRI), i));\n   }\n   for (let i = WIDTH; i < soil.length / 2 - WIDTH; i++) {\n      soilInfo.push(new soilCell(\n         soil[i].className, \n         Math.floor(Math.random() * (MAX_NUTRI-LOWEST_STARTING_NUTRI) + LOWEST_STARTING_NUTRI), i));\n   }\n   for (let i = soil.length / 2 - WIDTH; i < soil.length; i++) {\n      soilInfo.push(new soilCell(\n         soil[i].className, \n         Math.floor(Math.random() * (MAX_NUTRI-LOWEST_STARTING_NUTRI) + LOWEST_STARTING_NUTRI), i));\n   }\n} \n\nfunction createMycor() {\n   // store all mycor in mycorInfo and populate soil randomly with micorrhizal fungi\n   for (let num = 0; num < MYCOR_NUM; num++) {\n      let velX = Math.round(Math.random() * 2.0 - 1.0);\n      let velY = Math.round(Math.random() * 2.0 - 1.0);\n      let vel = [velX, velY];\n      let randIndex = Math.floor(Math.random() * (soil.length-WIDTH) + WIDTH);\n\n      if (velX == 0 && velY == 0) { vel[Math.floor(Math.random() * 2)] = 1; }\n\n      mycorInfo.push(new mycor(vel, 1.0, 5.0, randIndex))\n      soil[randIndex].className = soil[randIndex].className.concat(' mycor');\n      soilInfo[randIndex].organism = mycorInfo[mycorInfo.length - 1];\n   }\n}\n\nfunction toggleHRoot(cell) {\n   // click to make horizontal root,\n   // reduce soil nutri level by 1\n   cell.addEventListener('click', () => {\n      cell.classList.toggle('h_root');\n      soilInfo[cell.id].state = cell.className;\n      soilInfo[cell.id].nutri -= 1;\n      console.log(cell);\n   });\n}\n\nfunction toggleVRoot(cell) {\n   // double click to make vertical root,\n   // reduce soil nutri level by 1\n   cell.addEventListener('click', () => {\n      cell.classList.toggle('v_root');\n      soilInfo[cell.id].state = cell.className;\n      soilInfo[cell.id].nutri -= .5;\n      console.log(cell);\n   })\n}\n\n\n// ====================\n// grow roots and fungi\n// ====================\n\nfunction hypotenuse(x, y) {\n   return Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));\n}\n\n\nfunction mostNutri(lst) {\n   // given an array of soilCells, return [cell] with most nutri lvl \n   // if multiple items in array have the same nutri value, and the cells\n   // are not next to each other, return both in the same array \n   let l = lst;\n   // check lst length is 3\n   if (l.length === 1) return l;\n\n   if (l[0].nutri < l[1].nutri) { l.splice(0,1); }\n   else { l.splice(1,1); }\n\n   if (l.length === 2 && l[0].nutri == l[1].nutri) {\n      if (l[0].id == (l[1].id - 45) || l[0].id == (l[1].id - 1)) {\n         l.splice(1,1); }\n      else { return l; }\n   }\n\n   return mostNutri(l)\n}\n\nfunction arrIncludes(arr, str) {\n   // checks if any strings in an array of strings includes the given str\n   let a = arr;\n\n   if (a.length > 1 && !a[0].includes(str)) { a.splice(0,1); }\n   else {return a[0].includes(str)}\n\n   return arrIncludes(a, str)\n}\n\nfunction arrClassIncludes (arr, str) {\n   // checks of an array of objects (classes) includes the given str\n   //let a = arr;\n   let next = [];\n\n   if (arr.length > 1 && !arr[0].state.includes(str)) { next = arr.slice(1); }\n   else { return arr[0].state.includes(str) }\n\n   return arrClassIncludes(next, str)\n}\n\n\n\n\n/*\nfunction mycorNeighbours(cell) {\n   // return an array of [soilCell] of a mycor cell's neighbours\n   let n = [];\n   let x = coordX(cell);\n   let y = coordY(cell);\n   \n   for (dx = -3; dx < 4; dx++) {\n      for (dy = -3; dy < 4; dy++) {\n         let nx = (x + dx + WIDTH) % WIDTH;\n         let ny = (y + dy + HEIGHT) % HEIGHT;\n         n.push(soilInfo[coordToIndex([nx, ny])]);\n      }\n   }\n   n.splice(24,1);\n   return n;\n}\n\nfunction immediateNeighbours(cell) {\n   // return an array of [soilCell] of a cell's 8 immediate neighbours\n   let n = [];\n   let x = coordX(cell);\n   let y = coordY(cell);\n\n   for (dx = -1; dx < 2; dx++) {\n      for (dy = -1; dy < 2; dy++) {\n         let nx = (x + dx + WIDTH) % WIDTH;\n         let ny = (y + dy + HEIGHT) % HEIGHT;\n         n.push(soilInfo[coordToIndex([nx, ny])]);\n      }\n   }\n   n.splice(4,1);\n   return n\n}\n*/\n\nfunction rootVel(ogCell, relCell) {\n   // returns the location ('velocity') of relCell relative to ogCell\n   let ogX = coordX(ogCell);\n   let ogY = coordY(ogCell);\n   let relX = coordX(relCell);\n   let relY = coordY(relCell);\n   let vel = [0,0];\n\n   if (ogX > relX) { vel[0] = -1; }\n   else if (ogX < relX) { vel[0] = 1; }\n   \n   if (ogY > relY) { vel[1] = -1; }\n   else if (ogY < relY) { vel[1] = 1; }\n\n   // console.log(`cell ${ogCell.id} needs to go in direction \n   // ${vel} to get to cell ${relCell.id}`);\n   return vel\n}\n\n\nfunction mycorNeighbours(cell) {\n   // pass in soil[i] to get a mycor's next position and velocity \n   // based on its neighbours\n   let nCount = 0;\n   let x = coordX(cell);\n   let y = coordY(cell);\n   let avgPos = [0, 0];\n   let avgVel = [0, 0];\n   let radius = soilInfo[cell.id].organism.radius;\n   // let avoid = [x,y];\n   // let avoidDir = [];\n\n   // make mycor avoid top layer soil ?????\n\n   for (dx = -radius; dx <= radius; dx++) {\n      for (dy = -radius; dy <= radius; dy++) {\n         let nx = (x + dx + WIDTH) % WIDTH;\n         let ny = (y + dy + SOIL_HEIGHT) % SOIL_HEIGHT;\n         let nID = coordToIndex([nx, ny]);\n         \n         if (soil[nID].className.includes('mycor') &&\n         soilInfo[nID].nutri > 0) {\n            let nVel = soilInfo[nID].organism.vel;\n\n            avgPos[0] += nx;\n            avgPos[1] += ny;\n            avgVel[0] += nVel[0];\n            avgVel[1] += nVel[1];\n            nCount += 1;\n         }\n         else if ((soil[nID].className.includes('h_root') ||\n         soil[nID].className.includes('v_root')) //&&\n         /*soilInfo[nID].nutri > 0*/) {\n            // make it so mycor follows root growth direction more\n            let posMultiplier = 2;\n            let velMultiplier = 2;\n            avgPos[0] += (nx * posMultiplier);\n            avgPos[1] += (ny * posMultiplier);\n            // return relative location of root to mycor\n            let rVel = rootVel(cell, soil[nID]);\n            avgVel[0] += (rVel[0] * velMultiplier);\n            avgVel[1] += (rVel[1] * velMultiplier);\n            nCount += 1;\n         }\n\n         // console.log(`mycorNeighbour ID: ${nID}`);\n      }\n   }\n   // average and round the positions and velocities \n   avgPos[0] = (nCount > 0)? Math.round(avgPos[0] / nCount) : 0;\n   avgPos[1] = (nCount > 0)? Math.round(avgPos[1] / nCount) : 0;\n\n   \n   let avgPosLen = hypotenuse(avgPos[0], avgPos[1]);\n   if (avgPosLen > 0) {\n      avgPos[0] = Math.round(avgPos[0] / avgPosLen);\n      avgPos[1] = Math.round(avgPos[1] / avgPosLen);\n   }\n   \n   /*\n   avgVel[0] = (nCount > 0) ? Math.min(1, Math.max(-1, Math.round(avgVel[0] / nCount))) : 0;\n   avgVel[1] = (nCount > 0) ? Math.min(1, Math.max(-1, Math.round(avgVel[1] / nCount))) : 0;\n   */\n   avgVel[0] = (nCount > 0) ? Math.round(avgVel[0] / nCount) : 0;\n   avgVel[1] = (nCount > 0) ? Math.round(avgVel[1] / nCount) : 0;\n\n   // probably need to add separation in there \n   // to prevent multiples of the same index in mycorInfo!!!!!!!\n\n   // console.log(`mycorNeighbour avgPos: ${avgPos}, avgVel: ${avgVel}`);\n\n   return {\n      pos: avgPos,\n      vel: avgVel\n   };\n}\n\n\n\nfunction growMycor(i) {\n   // THIS WORKS BUT LOOK INTO IT MORE -- mycor maybe not growing the way you want \n   // ALSO DON'T GROW IF H_ROOT OR V_ROOT IS PRESENT \n   // also why does mycorInfo have repeating mycors ?? \n   let data = require('./mycor-params.js');\n   let {O_COEFF, A_COEFF, C_COEFF, S_COEFF, R_COEFF} = data;\n\n   let n = mycorNeighbours(soil[i]); \n   let x = coordX(soil[i]);\n   let y = coordY(soil[i]);\n\n   let newVel = soilInfo[i].organism.vel;\n   let randAdjustment = [\n      Math.round(Math.random() * 2.0 - 1.0),\n      Math.round(Math.random() * 2.0 - 1.0)\n   ];\n\n   newVel[0] = n.vel[0]; + n.pos[0] * 0.1;\n   newVel[1] = n.vel[1]; + n.pos[1] * 0.1;\n\n   /*\n   newVel[0] = \n      O_COEFF * newVel[0] +\n      A_COEFF * n.vel[0] +\n      C_COEFF * n.pos[0] +\n      R_COEFF * randAdjustment[0];\n\n   newVel[1] = \n      O_COEFF * newVel[1] +\n      A_COEFF * n.vel[1] +\n      C_COEFF * n.pos[1] +\n      R_COEFF * randAdjustment[1];\n   */\n\n   \n   let newVelLen = hypotenuse(newVel[0], newVel[1]);\n\n   if (newVelLen > 0) {\n      newVel[0] = Math.round(newVel[0] / newVelLen);\n      newVel[1] = Math.round(newVel[1] / newVelLen);\n   }\n   \n   \n\n   let nx = (x + newVel[0] + WIDTH) % WIDTH;\n   let ny = (y + newVel[1] + SOIL_HEIGHT) % SOIL_HEIGHT;\n   let newMycorID = coordToIndex([nx, ny]);\n\n   if (!soil[newMycorID].className.includes('mycor') &&\n       !soil[newMycorID].className.includes('h_root') &&\n       !soil[newMycorID].className.includes('v_root') //&&\n       /* soilInfo[newMycorID].nutri > 0 */) {\n         let newMycor = new mycor(newVel, 1, MYCOR_RADIUS, newMycorID);\n      \n         soilInfo[newMycorID].organism = newMycor;\n         \n         mycorInfo.push(newMycor);\n\n      // console.log(`nx: ${nx}, ny: ${ny}`);\n      // console.log(`growMycor newVel: ${newVel}`);\n      // console.log(`newMycorID: ${newMycorID}, prev cell: ${i}`);\n   }\n\n   \n\n   // if the same ID already exists in mycorInfo, replace that one with newMycor \n\n   /*\n   mycorInfo.forEach(function(mycor) \n      { if (mycor.id !== newMycorID) mycorInfo.push(newMycor); })\n      */\n\n   /*for (let i = 0; i < mycorInfo.length; i++) {\n      if (mycorInfo[i].id == newMycorID) { mycorInfo[i] = newMycor; }\n      else { mycorInfo.push(newMycor); }\n   } */\n   \n   \n   /*\n   if (arrClassIncludes(n, 'h_root') || arrClassIncludes(n, 'v_root') ||\n   arrClassIncludes(n, 'mycor')) {\n      // if mycor neighbours include roots or other mycors, \n      // grow towards their average\n      targets = n.filter(cell => cell.state.includes('mycor'));\n      targets = targets.concat(n.filter(cell => cell.state.includes('v_root')));\n      targets = targets.concat(n.filter(cell => cell.state.includes('h_root')));\n\n   }\n   */\n}\n\n\n\nfunction cleanMycorInfo() {\n   let unique = []\n   let uniqueID = []\n\n   mycorInfo.forEach((mycor) => {\n      if (!uniqueID.includes(mycor.id)) {\n         unique.push(mycor);\n         uniqueID.push(mycor.id);\n      }\n   })\n   mycorInfo = unique;\n}\n\n\n\nfunction vNeighbours(cell) {\n   // return an array [soilCell] of a soil cell's vertical neighbours \n   let n = [];\n   let x = coordX(cell);\n   let y = coordY(cell);\n   let ny = (y + 1 + SOIL_HEIGHT) % SOIL_HEIGHT;\n\n   for (let dx = -1; dx < 2; dx++) {\n      let nx = (x + dx + WIDTH) % WIDTH;\n      n.push(soilInfo[coordToIndex([nx, ny])]);\n   }\n   return n\n}\n\nfunction growVRoot(i) {\n   // turn 1 or 2 cells below an existing v_root into a v_root every iteration\n   // the cell with the highest nutri lvl will be turned into a v_root \n   // if two cells have the same high nutri lvl and the two cells are not \n   // together, v_root will grow on both cells \n   let nb = vNeighbours(soil[i]);\n   let nbState = [];\n\n   // filter out mycor cells\n   // nb = nb.filter(cell => !cell.className.includes('mycor'));\n\n   for (let j = 0; j < nb.length; j++) {\n      nbState.push(nb[j].state);\n   }\n\n   // if bottom neighbours not occupied, grow \n   if (!arrIncludes(nbState, 'v_root') && !arrIncludes(nbState, 'mycor')) {\n      // choose cell with largest soil nutri value to grow into \n      let grow = mostNutri(nb); \n\n      for (let k = 0; k < grow.length; k++) {\n         if (soilInfo[grow[k].id].state.includes('h_root') &&\n         soilInfo[grow[k].nutri > 0]) { \n            growHVRoot(grow[k].id) \n         }\n         else if (soilInfo[grow[k].id].nutri > 0) {\n            soilInfo[grow[k].id].state = soilInfo[grow[k].id].state.concat(' v_root');\n            soilInfo[grow[k].id].nutri -= 1;\n            // console.log('new v_root: ' + grow[k].id);\n         }\n      }\n   }\n}\n\nfunction hNeighbours(cell, dir) {\n   // return an array [soilCell] of a soil cell's horizontal neighbours \n   let x = coordX(cell);\n   let y = coordY(cell);\n   let n = [];\n\n   for (let dx = -1; dx < 2; dx += 2) {\n      for (let dy = -1; dy < 2; dy++) {\n         let nx = (x + dx + WIDTH) % WIDTH;\n         let ny = (y + dy + SOIL_HEIGHT) % SOIL_HEIGHT;\n\n         n.push(soilInfo[coordToIndex([nx,ny])]);\n      }\n   }\n   // remove some cells from array according to 'dir'\n   if (dir == 'both') {\n      return n;\n   } else if (dir == 'l') {\n      return n.splice(0,3);\n   } else if (dir == 'r') {\n      return n.splice(3);\n   } else {\n      return 'hNeighbours invalid cell direction'\n   }\n}\n\n\n// don't allow hRoot to grow where nutri lvl is 0 \nfunction growHRoot(i) {\n   // make root grow horizontally on both sides by 1 cell every iteration\n   // root finds the soil cell with largest nutri level to grow into\n   // if two cells have the same nutri lvl, grow into both \n   // if root reaches top of soil, grow stem\n   let nb = hNeighbours(soil[i], 'both');\n   let lnb = nb.slice(0,3);\n   let rnb = nb.slice(3);\n   let nbState = [];\n   // let nbID = [];\n\n   for (let j = 0; j < nb.length; j++) {\n      nbState.push(nb[j].state);\n      // nbID.push(nb[j].id);\n   }\n\n   let lnbState = nbState.slice(0,3);\n   let rnbState = nbState.slice(3);\n\n   // case 1: lone cell, grow on both left and right neighbours\n   if (!arrIncludes(nbState, 'h_root') && !arrIncludes(nbState, 'mycor')) {\n      let growL = mostNutri(lnb);\n      let growR = mostNutri(rnb); \n\n      for (let k = 0; k < growL.length; k++) {\n         if (soilInfo[growL[k].id].state.includes('h_root')) { growHVRoot(growL[k].id) }\n         else if (soilInfo[growL[k].id].nutri > 0) {\n            soilInfo[growL[k].id].state = soilInfo[growL[k].id].state.concat(' h_root');\n            soilInfo[growL[k].id].nutri -= 1;\n            // console.log('new h_root: ' + growL[k].id);\n         }\n      }\n      for (let k = 0; k < growR.length; k++) {\n         if (soilInfo[growR[k].id].state.includes('h_root')) { growHVRoot(growR[k].id) }\n         else if (soilInfo[growR[k].id].nutri > 0) {\n            soilInfo[growR[k].id].state = soilInfo[growR[k].id].state.concat(' h_root');\n            soilInfo[growR[k].id].nutri -= 1;\n            // console.log('new h_root: ' + growR[k].id);\n         }\n      }\n   }\n   // case 2: if cell is the left end of the root, grow on left neighbours only\n   else if (!arrIncludes(lnbState, 'h_root') && !arrIncludes(lnbState, 'mycor')) {\n      let grow = mostNutri(lnb);\n\n      for (let k = 0; k < grow.length; k++) {\n         if (soilInfo[grow[k].id].state.includes('h_root')) { growHVRoot(grow[k].id) }\n         else if (soilInfo[grow[k].id].nutri > 0) {\n            soilInfo[grow[k].id].state = soilInfo[grow[k].id].state.concat(' h_root');\n            soilInfo[grow[k].id].nutri -= 1;\n            // console.log('new h_root: ' + grow[k].id);\n         }\n      }\n   } \n   // case 3: if cell is on right end of root, grow on right neighbours only\n   else if (!arrIncludes(rnbState, 'h_root') && !arrIncludes(rnbState, 'mycor')) {\n      let grow = mostNutri(rnb);\n\n      for (let k = 0; k < grow.length; k++) {\n         if (soilInfo[grow[k].id].state.includes('h_root')) { growHVRoot(grow[k].id) }\n         else if (soilInfo[grow[k].id].nutri > 0) {\n            soilInfo[grow[k].id].state = soilInfo[grow[k].id].state.concat(' h_root');\n            soilInfo[grow[k].id].nutri -= 1;\n            // console.log('new h_root: ' + grow[k].id);\n         }\n      }\n   } \n}\n\nfunction growHVRoot(i) {\n   soilInfo[i].state = 'soil hv_root';\n   soilInfo[i].nutri -= 3;\n}\n\nfunction reduceNutrient(i) {\n   if (soil[i].className.includes('h_root') ||\n   soil[i].className.includes('v_root') ||\n   soil[i].className.includes('mycor') // ||\n   // soil[i].className.includes('ud_plant1') ||\n   // soil[i].className.includes('root1') ||\n   /* soil[i].className.includes('seed1') */) {\n      if (soilInfo[i].nutri > 0) soilInfo[i].nutri -= .5;\n      // console.log(`soil cell ${i} nutrient lvl reduce by 1`)\n\n      // if soil cell runs out of nutrients\n      if (soilInfo[i].nutri <= 0) {\n         let stotal = WIDTH * SOIL_HEIGHT;\n         if (i < WIDTH) soilInfo[i].state = 'soil organic';\n         else if (i >= WIDTH && i < stotal / 2 - WIDTH) soilInfo[i].state = 'soil topsoil';\n         else if (i < stotal) soilInfo[i].state = 'soil subsoil';\n\n         // remove from mycorInfo too!! \n         // but not sure why mycor disappears all together\n         for (let i = 0; i < mycorInfo.length; i++) {\n            if (mycorInfo[i].id = i) mycorInfo.splice(i, 1);\n         } \n      }\n   }\n   if (soil[i].className.includes('mycor')) {\n      soilInfo[i].nutri += .5;\n   }\n}\n\n\nmodule.exports = {\n   soil: soil,\n   soilInfo: soilInfo,\n   mycorInfo: mycorInfo,\n   arrIncludes,\n   createSoil, \n   loadSoilInfo, \n   createMycor, \n   toggleHRoot, \n   toggleVRoot, \n   mostNutri,\n   growMycor, \n   growVRoot, \n   growHRoot, \n   growHVRoot,\n   reduceNutrient\n};", "// this allows plants to grow above soil\n\n// edit flower growth so stem wont continue to grow above flower when watering \n\n\n// ========\n// set up\n// ========\n\nimport \"./style/main.css\";\nimport {coordY, coordX, coordToIndex} from './index-coord-helper.js';\n\nlet worldParams = require('./world-params.js');\nlet {WIDTH, SKY_HEIGHT, SOIL_HEIGHT, HEIGHT, LOW_NUTRI, frame} = worldParams;\n\nlet soilActs = require('./soil-activities.js');\nlet soil = soilActs.soil;\nlet soilInfo = soilActs.soilInfo;\n\n/*\nlet plant1 = require('./single-seed.js');\nlet {\n   allPlants,\n   findIndex,\n   findSeedID,\n} = plant1\n*/\n\nlet sky = []; \nlet plantInfo = [];\n\n\nclass plant {\n   constructor(len, state, id) {\n      this.len = len;      //the length that the stem should be\n      this.state = state;  // divides sky into vertical strips\n      this.id = id;        // the index of the plant cell in the sky grid \n   }\n}\n\nfunction createSky() {\n   for (let i = 0; i < WIDTH*SKY_HEIGHT; i++) {\n      const cell = document.createElement('div');\n      cell.classList.add(\"sky\");\n      cell.setAttribute('id',i);\n      frame.appendChild(cell);\n      sky.push(cell);\n   }\n}\n\n\nfunction loadPlantInfo() {\n   // create a plant class for each vertical sky strip, with 45 (WIDTH) strips\n   // total, load in random stem length, state, and cell id \n   for (let i = 0; i < WIDTH; i++) {\n      let id = [];\n      let state = [];\n      for (let j = i; j < sky.length; j += WIDTH) {\n         id.push(j);\n         state.push('sky');\n         // for whatever reason creating a list of sky's and pushing the list \n         // without the loop doesn't work later down the code \n      }\n      plantInfo.push(new plant(\n         Math.floor(Math.random() * (8-4) + 4), state, id\n      ));\n   }\n}\n\n/*\nfunction toggleHPlant(cell) {\n   // click to make h_plant stem\n   let x = coordX(cell);\n   let y = coordY(cell);\n\n   cell.addEventListener('click', () => {\n      cell.classList.toggle('h_plant');\n      plantInfo[x].state[y] = cell.className;\n      console.log(cell);\n   })\n}\n\nfunction toggleVPlant(cell) {\n   // click to make v_plant stem\n   let x = coordX(cell);\n   let y = coordY(cell);\n\n   cell.addEventListener('dblclick', () => {\n      cell.classList.toggle('v_plant');\n      plantInfo[x].state[y] = cell.className;\n      console.log(cell);\n   })\n}\n*/\n\n\n// ===========\n// grow plants\n// ===========\n\nfunction growBud(i) {\n   // if an h_root reaches the top of the soil, start growing a bud for h_plant\n   let diff = WIDTH * (SKY_HEIGHT - 1);   // or sky.length - WIDTH\n   // diff = difference between first row of soil cell and last row of sky cell\n   let x = coordX(sky[i]);\n   let y = coordY(sky[i]);\n\n   if (soil[i - diff].className == 'soil organic h_root') {\n      plantInfo[x].state[y] = 'sky h_plant';\n      // console.log(i);\n      // console.log(x);\n      // console.log(y);\n   }\n   else if (soil[i - diff].className == 'soil organic v_root') {\n      plantInfo[x].state[y] = 'sky v_plant';\n   }\n}\n\nfunction growPlants(i) {\n   // if there's an existing bud and the plant's length < a plant's ideal length,\n   // grow 1 stem cell for h and v\n   let top = i - WIDTH;\n   let bot = i + WIDTH; \n   let x = coordX(sky[i]);\n   let y = coordY(sky[i]);\n   let hstem = plantInfo[x].state.filter(cell => cell.includes('h_plant'));\n   let vstem = plantInfo[x].state.filter(cell => cell.includes('v_plant'));\n   let plant1stem = plantInfo[x].state.filter(cell => cell.includes('ab_plant1'))\n\n   // grow h plant\n   if (sky[bot].className.includes('h_plant') && \n   !sky[top].className.includes('h_flower') && \n   !sky[top].className.includes('v_plant') &&\n   !sky[top].className.includes('water') &&\n   hstem.length < plantInfo[x].len) {\n      plantInfo[x].state[y] = 'sky h_plant';\n      // console.log('new stem at ' + i);\n   }\n   // grow h flower\n   else if (sky[bot].className.includes('h_plant') &&\n   !sky[top].className.includes( 'h_flower') && \n   hstem.length == plantInfo[x].len) {\n      plantInfo[x].state[SKY_HEIGHT - hstem.length - 1] = 'sky h_flower';\n      // console.log('new flower at ' + i);\n   }\n   // grow v plant\n   else if (sky[bot].className.includes('v_plant') && \n   !sky[top].className.includes('v_flower') && \n   !sky[top].className.includes('h_plant') &&\n   !sky[top].className.includes('water') &&\n   vstem.length < plantInfo[x].len) {\n      plantInfo[x].state[y] = 'sky v_plant';\n   }\n   // grow v flower\n   else if (sky[bot].className.includes('v_plant') &&\n   !sky[top].className.includes('v_flower') && \n   vstem.length == plantInfo[x].len) {\n      plantInfo[x].state[SKY_HEIGHT - vstem.length - 1] = 'sky v_flower';\n   }\n   /*\n   // grow plant1\n   else if (sky[bot].className.includes('ab_plant1') &&\n   !sky[top].className.includes('flower1') &&\n   !sky[top].className.includes('water') &&\n   plant1stem.length < plantInfo[x].len) {\n      plantInfo[x].state[y] = 'sky ab_plant1';\n   }\n   // grow flower1 \n   else if (sky[bot].className.includes('ab_plant1') &&\n   !sky[top].className.includes('flower1') &&\n   plant1stem.length == plantInfo[x].len) {\n      plantInfo[x].state[SKY_HEIGHT - plant1stem.length - 1] = 'sky flower1';\n      // once flower grows, set new max root length \n   }\n   */\n}\n\n\n// =============\n// wilt plants\n// =============\n\nfunction wiltPlant(i) {\n   // if flower is wilted and root is still low on nutrients, \n   // start wilting rest of the plant \n   let diff = WIDTH * (SKY_HEIGHT - 1);  // difference between first row of soil cell and last row of sky cell\n   let x = coordX(sky[i]);\n   let y = coordY(sky[i]);\n\n   if (sky[i].className.includes('h_flower_wilted') || \n   sky[i].className.includes('h_plant_wilted')) {\n      let budID = plantInfo[x].id[SKY_HEIGHT - 1];\n      let soilID = budID - diff;\n\n      if (soilInfo[soilID].nutri <= LOW_NUTRI && \n         !sky[i + WIDTH].className.includes('h_plant_wilted')) {\n            plantInfo[x].state[y+1] = 'sky h_plant_wilted'; \n      }\n   }\n   if (sky[i].className.includes('v_flower_wilted') || \n   sky[i].className.includes('v_plant_wilted')) {\n      let budID = plantInfo[x].id[SKY_HEIGHT - 1];\n      let soilID = budID - diff;\n\n      if (soilInfo[soilID].nutri <= LOW_NUTRI && \n         !sky[i + WIDTH].className.includes('v_plant_wilted')) {\n            plantInfo[x].state[y+1] = 'sky v_plant_wilted'; \n      }\n   }\n}\n\nfunction wiltFlower(i) {\n   // if nutri lvl of top-most root cell of plant is low on nutrients, \n   // flower will start to wilt \n   let diff = WIDTH * (SKY_HEIGHT - 1);  // difference between first row of soil cell and last row of sky cell\n   let x = coordX(sky[i]);\n   let y = coordY(sky[i]);\n\n   if (sky[i].className.includes('h_flower')) {\n      let budID = plantInfo[x].id[SKY_HEIGHT - 1];\n      let soilID = budID - diff;\n\n      if (soilInfo[soilID].nutri <= LOW_NUTRI) {\n         plantInfo[x].state[y] = 'sky h_flower_wilted'; \n      }\n   }\n   if (sky[i].className.includes('v_flower')) {\n      let budID = plantInfo[x].id[SKY_HEIGHT - 1];\n      let soilID = budID - diff;\n\n      if (soilInfo[soilID].nutri <= LOW_NUTRI) {\n         plantInfo[x].state[y] = 'sky v_flower_wilted'; \n      }\n   }\n}\n\nfunction plantGone(i) {\n   let diff = WIDTH * (SKY_HEIGHT - 1);  // difference between first row of soil cell and last row of sky cell\n   let x = coordX(sky[i]);\n   let y = coordY(sky[i]);\n\n   if (sky[i].className.includes('h_flower_wilted')) {\n      let budID = plantInfo[x].id[SKY_HEIGHT - 1];\n      let rootID = budID - diff;\n\n      if (!plantInfo[x].state.includes('sky h_flower') &&\n      !plantInfo[x].state.includes('sky h_plant') &&\n      !soil[rootID].className.includes('h_root')) {\n\n         for (let j = 0; j < SKY_HEIGHT; j++) {\n            if (!plantInfo[x].state[j].includes('hose')){\n               plantInfo[x].state[j] = 'sky';\n            }\n         }\n      }\n   }\n   if (sky[i].className.includes('v_flower_wilted')) {\n      let budID = plantInfo[x].id[SKY_HEIGHT - 1];\n      let rootID = budID - diff;\n\n      if (!plantInfo[x].state.includes('sky v_flower') &&\n      !plantInfo[x].state.includes('sky v_plant') &&\n      !soil[rootID].className.includes('v_root')) {\n\n         for (let j = 0; j < SKY_HEIGHT; j++) {\n            if (!plantInfo[x].state[j].includes('hose')){\n               plantInfo[x].state[j] = 'sky';\n            }\n         }\n      }\n   }\n   \n}\n\n\n\n\nmodule.exports = {\n   sky,\n   plantInfo,\n   createSky,\n   loadPlantInfo,\n   // toggleHPlant,\n   // toggleVPlant,\n   growBud,\n   growPlants,\n   wiltFlower,\n   wiltPlant,\n   plantGone\n}\n", "// visualizes nutrition distribution in soil when button is clicked \n// and where water travels after it seeps into the soil\n\n\n/*\nTo Do's\n- allow nutrients to distribute, not just to immediate neighbours \n   - ex. if nutri level is maxed, distribute 1 to nearest neighbour(s) \n*/\n\nimport './style/nutri-grid.css';\nimport {coordY, coordX, coordToIndex} from './index-coord-helper.js';\n\nlet worldParams = require('./world-params.js');\nlet {\n   WIDTH, \n   SOIL_HEIGHT, \n   LOWEST_STARTING_NUTRI, \n   LOW_NUTRI, \n   MAX_NUTRI, \n   FLOOD_THRESHOLD,\n   WATER_NUTRI_VAL} = worldParams;\n\nlet soilActivities = require('./soil-activities.js');\nlet soilInfo = soilActivities.soilInfo;\n\nconst nutriFrame = document.querySelector('.nutri_frame');\nlet soilNutri = [];  // node list of nutri cells\nlet soilNutriRec = []; // record of soilNutri class names for doing updates\n\n\n\nfunction createSoilNutri() {\n   // creates grid that will be used to show soil nutri value\n   // hidden from main grid unless clicked on \n   let stotal = WIDTH * SOIL_HEIGHT;\n   for(let i=0; i < stotal; i++) {\n      const cell = document.createElement('div');\n      cell.classList.add(\"soil-nutri\");\n      cell.setAttribute('id',i);\n      nutriFrame.appendChild(cell);\n      soilNutri.push(cell);\n   }\n   for (let i = 0; i < WIDTH*SOIL_HEIGHT; i++) {\n      soilNutri[i].classList.add(\"nutri_soil\");\n      soilNutriRec.push(soilNutri[i].className);\n   }\n}\n\nfunction updateNutriRec() {\n   for (let i = 0; i < soilNutriRec.length; i++) {\n      if (soilInfo[i].nutri < LOW_NUTRI &&\n         !soilNutriRec[i].includes('low-nutri')) {\n         // soilNutri[0].className = soilNutri[0].className.concat(' low-nutri');\n         soilNutriRec[i]= soilNutriRec[i].concat(' low-nutri');\n         // console.log(`cell ${i} is dying!!`);\n      }\n      if (soilInfo[i].nutri >= LOW_NUTRI && \n         soilInfo[i].nutri < LOWEST_STARTING_NUTRI + 2 &&\n         !soilNutriRec[i].includes('med-nutri')) {\n         soilNutriRec[i] = soilNutriRec[i].concat(' med-nutri');\n      }\n      if (soilInfo[i].nutri > MAX_NUTRI) {\n         soilNutriRec[i] = soilNutriRec[i].replace('low-nutri', '');\n         soilNutriRec[i] = soilNutriRec[i].replace('med-nutri', '');\n      }\n      if (soilInfo[i].nutri <= 0 &&\n         !soilNutriRec[i].includes('dead-nutri')) {\n            soilNutriRec[i] = soilNutriRec[i].concat(' dead-nutri');\n\n      }\n   }\n}\n\nfunction showNutri() {\n   // overlays nutrient distribution grid on screen\n   let hiddenNutri = document.getElementsByClassName(\"hidden-nutri\")[0];\n   hiddenNutri.classList.toggle('show-nutri');\n\n   //console.log('showNutri() should be working')\n   //console.log(hiddenNutri.classList);\n}\n\n\nfunction nutriNeighbours(cell) {\n   let x = coordX(cell);\n   let y = coordY(cell);\n   let neighbours = [];\n\n   for (let dx = -1; dx < 2; dx++) {\n      for (let dy = 0; dy < 2; dy++) {\n         let nx = (x + dx + WIDTH) % WIDTH;\n         let ny = (y + dy + SOIL_HEIGHT) % SOIL_HEIGHT;\n         let nID = coordToIndex([nx, ny]);\n\n         neighbours.push(soilNutri[nID].id);\n      }\n   }\n   return neighbours;\n}\n\n\nfunction waterNutriFlow() {\n   // directs how water flows within nutri grid \n   // water flows downwards and also hydrates nearest neighbours\n   // right now it's impossible to over water .. \n   for (let i = 0; i < soilNutri.length; i++) {\n\n      if (soilInfo[i].nutri > FLOOD_THRESHOLD &&\n         !soilNutriRec[i].includes('soil-flood')) {\n         soilNutriRec[i] = soilNutriRec[i].concat(' soil-flood');\n      }\n      if (soilNutri[i].className.includes('soil-water')) {\n         let n = nutriNeighbours(soilNutri[i]); \n         \n         if (soilInfo[i].nutri <= MAX_NUTRI) {\n            soilInfo[i].nutri += WATER_NUTRI_VAL;\n            soilNutriRec[i] = soilNutriRec[i].replace(' soil-water', '');\n            // console.log(`nutri lvl at soil cell ${i}: ${soilInfo[i].nutri}`);\n            // console.log(`cell ${i} class name: ${soilNutriRec[i]}`);\n         }\n         else if (soilNutri[i].className.includes('soil-water') &&\n         soilInfo[i].nutri > MAX_NUTRI &&\n         i < soilNutri.length - WIDTH) {\n            let below = i + WIDTH; \n            if (soilInfo[below].nutri <= MAX_NUTRI) soilInfo[below].nutri += WATER_NUTRI_VAL;\n            soilNutriRec[below] = soilNutriRec[below].concat(' soil-water');\n            soilNutriRec[i] = soilNutriRec[i].replace(' soil-water', '');\n            // console.log(`next cell (${below}) class name: ${soilNutriRec[below]}`);\n         }\n         // hydrate neighbours too! \n         for (let j = 0; j < n.length; j++) {\n            if (soilInfo[n[j]].nutri <= MAX_NUTRI) soilInfo[n[j]].nutri += WATER_NUTRI_VAL;\n         }\n      }\n   }\n}\n\n\n\nmodule.exports = {\n   nutriFrame,\n   soilNutri,\n   soilNutriRec,\n   createSoilNutri,\n   updateNutriRec,\n   showNutri,\n   waterNutriFlow\n}", "// kind of generalized function(s) to style elements on page\nimport \"./style/main.css\";\n\nfunction toggleBtnOnOff(element) {\n   // button changes color when clicked\n   if (element.className !== 'toggled') {\n      element.className = 'toggled'\n   }\n   else { element.className = ''; }\n}\n\n\nfunction fadeElem(elem, duration, finalOpacity) {\n   // fade an html element on screen \n   // duration in miliseconds - int\n   // finalOpacity - string\n   let start = new Date; \n   (function next() {\n      let time = new Date - start;\n      if (time < duration) {\n         elem.style.opacity = 1 - time/duration;\n         requestAnimationFrame(next);\n      } \n      else {\n         elem.style.opacity = finalOpacity;\n      }\n   })();\n}\n\n\n\nmodule.exports = {\n   toggleBtnOnOff,\n   fadeElem\n}", "/* \nCode for:\n- building hoses\n- checking for spigots\n- checking if complete hoses are built at the end of existing spigots\n- turning on water for built hoses\n*/\n\n// rn the hose doesn't work when crinkled, pls fix \n// water not passing through wilted flower \n// water might not be getting into the ground when there is flower \n\n// ======\n// set up\n// ======\n\nimport \"./style/main.css\";\nimport \"./style/nutri-grid.css\"\nimport {coordY, coordX, coordToIndex} from './index-coord-helper.js'; \n\nlet worldParams = require('./world-params.js');\nlet {WIDTH, SKY_HEIGHT, SOIL_HEIGHT, HEIGHT, frame} = worldParams;\n\nlet skyActivies = require('./sky-activities.js');\nlet sky = skyActivies.sky;\nlet plantInfo = skyActivies.plantInfo;\n\nlet soilActivities = require('./soil-activities.js');\nlet soil = soilActivities.soil;\nlet soilInfo = soilActivities.soilInfo;\n\nlet nutriActivities = require('./nutri-grid.js');\nlet soilNutri = nutriActivities.soilNutri;\nlet soilNutriRec = nutriActivities.soilNutriRec;\n\nlet styling = require('./style-helper.js');\nlet {\n   toggleBtnOnOff\n} = styling;\n\n// buttons\nconst waterBtn1 = document.getElementById('activate_water');\n//const waterBtn2 = document.getElementById('water_btn2');\nconst hoseBtn1 = document.getElementById('activate_hose'); \n\nconst waterBtn = document.getElementById('water_btn');\nconst hoseBtn = document.getElementById('hose_btn');\n\n\n\n\nfunction buildHose(cell) {\n   // click on sky cells to make hose\n   let x = coordX(cell);\n   let y = coordY(cell);\n\n   cell.addEventListener('click', () => {\n      cell.classList.toggle('hose');\n      plantInfo[x].state[y] = cell.className;\n      console.log(cell);\n   })\n}\n\n\nfunction getSpigots() {\n   // returns array of built spigots (hose attachment to sides of sky)\n   // helper for waterOn()\n   let hoses = [];\n   for (let x = 0; x < WIDTH; x++) {\n      let id = coordToIndex([x,0]);\n\n      if (sky[id].className.includes('hose')) {\n         hoses.push(sky[id]);\n      }\n   }\n   for (let y = 0; y < SKY_HEIGHT; y++) {\n      let id = coordToIndex([0,y]);\n      let id2 = coordToIndex([WIDTH-1, y]);\n\n      if (sky[id].className.includes('hose')) {\n         hoses.push(sky[id]);\n      }\n      else if (sky[id2].className.includes('hose')) {\n         hoses.push(sky[id2]);\n      }\n   }\n   // console.log(hoses);\n   return hoses\n}\n\n\nfunction nextHoseCell(currentCell, prevCell = currentCell) {\n   // returns the next hose cell in an array\n   // returns an array of nozzle cells if it exists\n   let next = [];\n   let x = coordX(currentCell);\n   let y = coordY(currentCell);\n\n   // hose currently only extends from left and right borders and pointing \n   // downwards, so no need to check for neighbours above\n   // let topID = coordToIndex([x, y-1]);\n   let botID = coordToIndex([x, y+1]);\n   let leftID = coordToIndex([x-1, y]);\n   let rightID = coordToIndex([x+1, y]);\n\n   // check for next hose cell\n   let checklist = [ /* sky[topID], */ sky[botID], sky[leftID], sky[rightID]];\n\n   for (let i = 0; i < checklist.length; i++) {\n      if (checklist[i].className.includes('hose') && checklist[i] != prevCell) {\n         next.push(checklist[i]);\n         // console.log(`next hose cell: ${checklist[i].id}`)\n\n         // check whether there's a nozzle\n         // there must be a hose cell on top in addition to other code \n         if (sky[botID] == checklist[i]) {\n            let nx = coordX(checklist[i]);\n            let ny = coordY(checklist[i]);\n            // let nTopID = coordToIndex([nx, ny - 1]);\n            // let nBotID = coordToIndex([nx, ny + 1]);\n            let nLeftID = coordToIndex([nx - 1, ny]);\n            let nRightID = coordToIndex([nx + 1, ny]);\n\n            if (sky[nLeftID].className.includes('hose') &&\n            sky[nRightID].className.includes('hose') &&\n            sky[nLeftID] != checklist[i] &&\n            sky[nRightID] != checklist[i]) {\n               next.push(sky[nLeftID]);\n               next.push(sky[nRightID]);\n            }\n         }\n      }\n   }\n   return next;\n}\n\n\nfunction isHose(currentCell, prevCell = currentCell) {\n   // checks if a hose exists from a certain spigot\n   // if hose exists, also return center of spigot\n   let prev = prevCell;\n   let current = currentCell;\n   newHoseCell = nextHoseCell(current, prev);\n   // if (newHoseCell.length == 1) console.log(`next hose cell: ${newHoseCell[0].id}`);\n\n   if (newHoseCell.length == 1) {\n      prev = currentCell;\n      current = newHoseCell[0];\n      // console.log(`new previous: ${prev.id}`);\n      // console.log(`new current: ${current.id}`);\n      isHose(current, prev);\n   }\n\n   if (newHoseCell.length == 0) return false;\n   else if (newHoseCell.length == 3) return [true, newHoseCell[0]];\n   else { console.error('isHose error') }\n}\n\n\nfunction waterFlow(i) {\n   // used to step through water movemnets -- connect with step() \n   let ogX = coordX(sky[i]);\n   let ogY = coordY(sky[i]);\n\n   if (sky[i].className.includes('water') && \n   i < sky.length - WIDTH) {\n      let belowID = i + WIDTH; \n\n      if (!sky[belowID].className.includes('water')) {\n         let belowX = coordX(sky[belowID]);\n         let belowY = coordY(sky[belowID]);\n\n         plantInfo[ogX].state[ogY] = plantInfo[ogX].state[ogY].replace(' water', '');\n         plantInfo[belowX].state[belowY] = plantInfo[belowX].state[belowY].concat(' water');\n      }\n   }\n   // when water reaches the top of soil\n   else if (sky[i].className.includes('water') && \n   i > sky.length - WIDTH && i < sky.length) {\n      // find soil ID and set as belowID \n      let diff = WIDTH * (SKY_HEIGHT - 1);\n       // diff = difference between first row of soil cell and last row of sky cell\n      let belowID = i - diff;\n      // console.log(`soil cell to water: ${belowID}`)\n      soilNutriRec[belowID] = soilNutriRec[belowID].concat(' soil-water');\n      // soilInfo[belowID].nutri += 1;\n      plantInfo[ogX].state[ogY] = plantInfo[ogX].state[ogY].replace(' water', '');\n      // the way water moves through the rest of the nutri grid is coded in nutri-grid.js \n   }\n}\n\n\nfunction waterOn() {\n   // check perimeter of sky cells \n   // if there's a hose cell, follow the hose cell and check if there's a nozzle \n   // if a nozzel is built, turn cell below nozzle into water cell\n   let spigots = getSpigots()\n\n   if (spigots.length > 0) {\n      for (let i = 0; i < spigots.length; i++) {\n         if (isHose(spigots[i])[0]) {\n            // produce drop of water below nozzle\n            \n            let center = isHose(spigots[i])[1];\n            let waterID = Number(center.id) + WIDTH;\n            let waterX = coordX(sky[waterID]);\n            let waterY = coordY(sky[waterID]);\n\n            if (!plantInfo[waterX].state[waterY].includes('water')) {\n               plantInfo[waterX].state[waterY] = plantInfo[waterX].state[waterY].concat(' water');\n            }\n            sky[waterID].className = sky[waterID].className.concat(' water');\n            // console.log(`current spigot ${spigots[i].id} is a built hose`);\n         }\n      }\n   }\n   // console.log('waterOn is working');\n}\n\n\n\n// ===========================\n// buttons, execute functions\n// ===========================\n\nwaterBtn.addEventListener('click', function() {\n   toggleBtnOnOff(waterBtn);\n   waterOn();\n});\n\nhoseBtn.addEventListener('click', function() {\n   toggleBtnOnOff(hoseBtn);\n   sky.forEach((cell) => { buildHose(cell) });\n})\n\n\n\n// probably won't need this eventually\nmodule.exports = {\n   getSpigots,\n   nextHoseCell,\n   isHose,\n   waterFlow,\n   waterOn,\n   waterBtn\n}\n\n\n\n\n\n\n", "// grow a single plant from a single seed\n\nimport \"./style/main.css\";\nimport {coordY, coordX, coordToIndex} from './index-coord-helper.js';\n\nlet styling = require('./style-helper.js');\nlet {\n   toggleBtnOnOff\n} = styling;\n\nlet worldParams = require('./world-params.js');\nlet {\n   WIDTH, \n   SOIL_HEIGHT, \n   SKY_HEIGHT,\n   HEIGHT, \n   LOWEST_STARTING_NUTRI, \n   LOW_NUTRI,\n   MAX_NUTRI, \n   ROOT_LEN_FOR_PLANT,\n   MAX_ROOT_LEN,\n   CONT_ROOT_GROW,\n   ROOT_MULTIPLIER,\n   frame} = worldParams;\n\nlet soilActivities = require('./soil-activities.js');\nlet {\n   arrIncludes,\n   soil, \n   soilInfo,\n   mycorInfo,\n   createSoil, \n   loadSoilInfo, \n   mostNutri,\n   reduceNutrient\n} = soilActivities;\n\nlet skyActivities = require('./sky-activities.js');\nlet {\n   sky,\n   plantInfo\n} = skyActivities\n\nclass singlePlant {\n   constructor(id, rootLen, maxRootLen, rootList, soilPlantList) {\n      this.id = id;                          // ID of initial seed placement\n      this.rootLen = rootLen;                // length of root\n      this.maxRootLen = maxRootLen,          // maximum length of root\n      this.rootList = rootList;              // list of all root cells IDs associated with this seed\n      this.soilPlantList = soilPlantList;    // list of underground plant cells \n   }\n}\n\nclass skyCell {\n   constructor(state, id) {\n      this.state = state;\n      this.id = id;\n   }\n}\n\nlet allPlants = [];\nlet skyInfo = [];\n\n\n\n// =================\n// grow underground\n// =================\n\nfunction toggleSeed1(cell) {\n   // click to make single root,\n   // reduce soil nutri level by 1\n   cell.addEventListener('click', () => {\n      cell.classList.toggle('seed1');\n      soilInfo[cell.id].state = cell.className;\n      soilInfo[cell.id].nutri -= 1;\n      allPlants.push ( new singlePlant( Number(cell.id), 1, MAX_ROOT_LEN, \n      [Number(cell.id)], []));\n      console.log(cell)\n   });\n}\n\n/*\nfunction loadSkyInfo() {\n   for (let i = 0; i < SKY_HEIGHT * WIDTH; i++) {\n      skyInfo.push(new skyCell( sky[i].className, i ));\n   }\n}\n*/\n\nfunction avgPlant1SoilNutri(i) {\n   // given any id, calculate the average nutri level of plant1 in soil \n   let seedID = findSeedID(i);\n   let allPlantsPos = findIndex(allPlants, seedID); \n   // console.log(`id: ${i}, seedID: ${seedID}, allPlantsPos: ${allPlantsPos}`)\n   let rootList = allPlants[allPlantsPos].rootList;\n   let soilPlantList = allPlants[allPlantsPos].soilPlantList;\n   let totalNutri = 0; \n\n   for (let k = 0; k < rootList.length; k++) {\n      let cellID = rootList[k];\n      totalNutri += soilInfo[cellID].nutri;\n   }\n   // console.log(`totalNutri in rootList: ${totalNutri}`);\n   for (let j = 0; j < soilPlantList.length; j++) {\n      let cellID = soilPlantList[j];\n      totalNutri += soilInfo[cellID].nutri;\n   }\n   // console.log(`totalNutri in rootList + soilPlantList: ${totalNutri}`);\n   return {\n      allPlantsPos: allPlantsPos,\n      avgPlantNutri: totalNutri / (rootList.length + soilPlantList.length)\n   };\n}\n\nfunction findIndex(arr, index) {\n   // array of class objects, grid-based index --> position in array (int)\n   // given the object's grid-based index, return the object's index in another array\n   let result = arr.find( ({id}) => Number(id) == Number(index) );\n   return arr.indexOf(result);\n}\n\nfunction root1Neighbours(cell) {\n   // return an array [soilCell] of a soil cell's nearest 3 neighbours below\n   // same as vRootNeighbours()\n   let n = [];\n   let x = coordX(cell);\n   let y = coordY(cell);\n   let ny = (y + 1 + SOIL_HEIGHT) % SOIL_HEIGHT;\n\n   for (let dx = -1; dx < 2; dx++) {\n      let nx = (x + dx + WIDTH) % WIDTH;\n      n.push(soilInfo[coordToIndex([nx, ny])]);\n   }\n   return n\n}\n\nfunction findSeedID(i) {\n   // search through rootList and soilPlantList in allPlants to find the seed ID, given i  \n   // let result = arr.find( ({id}) => Number(id) == i );\n\n   for (j = 0; j < allPlants.length; j++) {\n      for (k = 0; k < allPlants[j].rootList.length; k++) {\n         let searchID = allPlants[j].rootList[k];\n         if (searchID == i) { return allPlants[j].id }\n      }\n      for (l = 0; l < allPlants[j].soilPlantList.length; l++) {\n         let searchID = allPlants[j].soilPlantList[l];\n         if (searchID == i) { return allPlants[j].id }\n      } \n   }\n}\n\n\n// ========================\n// grow plant underground\n// ========================\n\nfunction growRoot1(i) {\n   // turn 1 or 2 cells below an existing seed or root into a new root every iteration\n   // the cell with the highest nutri lvl will be turned into a root \n   // if two cells have the same high nutri lvl and the two cells are not \n   // together, roots will grow on both cells \n   let nb = root1Neighbours(soil[i]);\n   let nbState = [];\n\n   // filter out mycor cells\n   // nb = nb.filter(cell => !cell.className.includes('mycor'));\n\n   for (let j = 0; j < nb.length; j++) {\n      nbState.push(nb[j].state);\n   }\n\n   let avg = avgPlant1SoilNutri(i); \n   let {allPlantsPos, avgPlantNutri} = avg\n\n   // if bottom neighbours not occupied, grow \n   if (!arrIncludes(nbState, 'root1') && !arrIncludes(nbState, 'seed1') &&\n   !arrIncludes(nbState, 'ud_plant1') && avgPlantNutri > LOW_NUTRI) {\n      // choose cell with largest soil nutri value to grow into \n      let grow = mostNutri(nb); \n      // find the cell's corresponding plant in allPlants\n      let seedID = findSeedID(i);\n      let allPlantsID = findIndex(allPlants, seedID);\n\n      for (let k = 0; k < grow.length; k++) {\n         if (soilInfo[grow[k].id].nutri > 0 &&\n            allPlants[allPlantsID].rootLen < allPlants[allPlantsID].maxRootLen) {\n            soilInfo[grow[k].id].state = soilInfo[grow[k].id].state.concat(' root1');\n            soilInfo[grow[k].id].nutri -= 1;\n            // console.log('new root1: ' + grow[k].id);\n\n            // update allPlants \n            allPlants[allPlantsID].rootLen += 1; \n            allPlants[allPlantsID].rootList.push(grow[k].id)\n         }\n      }\n   }\n}\n\nfunction growPlant1Under(i) {\n   // start growing plant from seed underground\n   \n   // find the corresponding plant in allPlants for seed index i \n   allPlantSeedID = findIndex(allPlants, i); \n   // look to see if cell directly above is occupied\n   let aboveID = i - WIDTH;\n\n   if (aboveID >= 0) {\n      // find plant in allPlants\n      let seedID = findSeedID(i)\n      let plantID = findIndex(allPlants, seedID);\n\n      let avg = avgPlant1SoilNutri(i); \n      let {allPlantsPos, avgPlantNutri} = avg\n\n      // if i is a seed \n      if (soil[i].className.includes('seed1') &&\n      allPlants[allPlantSeedID].rootLen > ROOT_LEN_FOR_PLANT &&\n      !soil[aboveID].className.includes('ud_plant1') &&\n      !soil[aboveID].className.includes('seed1') &&\n      avgPlantNutri > LOW_NUTRI) {\n         soilInfo[aboveID].state = soilInfo[aboveID].state.concat(' ud_plant1');\n         soilInfo[aboveID].nutri -= 1;\n         // console.log(`plant grown underground at ${aboveID}`)\n         // update udPlantList\n         allPlants[plantID].soilPlantList.push(aboveID);\n      }\n      // if i is a udPlant\n      if (soil[i].className.includes('ud_plant1') &&\n         !soil[aboveID].className.includes('ud_plant1') &&\n         !soil[aboveID].className.includes('root1') &&\n         !soil[aboveID].className.includes('seed1') &&\n         avgPlantNutri > LOW_NUTRI) {\n            soilInfo[aboveID].state = soilInfo[aboveID].state.concat(' ud_plant1');\n            soilInfo[aboveID].nutri -= 1;\n            // update udPlantList\n            allPlants[plantID].soilPlantList.push(aboveID);\n      }\n   }\n}\n\n\n\n// ==================\n// grow above ground\n// ==================\n\nfunction seed1Bud(i) {\n   // if plant1 reaches the top of the soil, start growing a bud for plant1\n   let diff = WIDTH * (SKY_HEIGHT - 1);   // or sky.length - WIDTH\n   // diff = difference between first row of soil cell and last row of sky cell\n   let x = coordX(sky[i]);\n   let y = coordY(sky[i]);\n\n   if (soil[i - diff].className.includes('ud_plant1') &&\n   !plantInfo[x].state[y].includes('ab_plant1')) {\n      let avg = avgPlant1SoilNutri(i-diff);\n      let {allPlantsPos, avgPlantNutri} = avg;\n\n      if (avgPlantNutri > LOW_NUTRI) {\n         plantInfo[x].state[y] = plantInfo[x].state[y].concat(' ab_plant1');\n         // let plantID = findSeedID(i-diff);\n         // console.log(`soil id under bud: ${i-diff}`)\n         // console.log(`plantID: ${plantID}`);\n         // allPlants[plantID].skyPlantList.push(i);\n         // console.log(i);\n         // console.log(x);\n         // console.log(y);\n      }\n   }\n}\n\nfunction growPlant1Above(i) {\n   // if there's an existing bud and the plant's length < a plant's ideal length,\n   // grow 1 stem cell \n   let top = i - WIDTH;\n   let bot = i + WIDTH; \n   let x = coordX(sky[i]);\n   let y = coordY(sky[i]);\n   let plant1stem = plantInfo[x].state.filter(cell => cell.includes('ab_plant1'))\n\n   // grow plant1\n   if (sky[bot].className.includes('ab_plant1') &&\n   !sky[top].className.includes('flower1') &&\n   !sky[top].className.includes('water') &&\n   plant1stem.length < plantInfo[x].len) {\n      plantInfo[x].state[y] = 'sky ab_plant1';\n   }\n   // grow flower1 \n   else if (sky[bot].className.includes('ab_plant1') &&\n   !sky[top].className.includes('flower1') &&\n   plant1stem.length == plantInfo[x].len) {\n      plantInfo[x].state[SKY_HEIGHT - plant1stem.length - 1] = 'sky flower1';\n\n      // once flower grows, change max root length to current root length\n      let budID = plantInfo[x].id[SKY_HEIGHT-1];\n      let diff = WIDTH * (SKY_HEIGHT - 1);\n      let topSoilRootID = budID - diff; \n      let seedID = findSeedID(topSoilRootID);\n      let plantID = findIndex(allPlants, seedID);\n      allPlants[plantID].maxRootLen = plant1stem.length * ROOT_MULTIPLIER;\n   }\n}\n\n\n\n// ============================\n// nutri control / plant decay\n// ============================\n\n\nfunction reducePlant1Nutri(i) {\n   // reduce the nutri level of plant1 \n   if (soil[i].className.includes('seed1') ||\n   soil[i].className.includes('ud_plant1') ||\n   soil[i].className.includes('root1')) {\n      // always reduce soil nutri every step \n      if (soilInfo[i].nutri > 0) soilInfo[i].nutri -= 1;\n      // console.log(`soil cell ${i} nutrient lvl reduce by 1`)\n   }\n   if (soil[i].className.includes('seed1')) {\n      // calculate the average nutri level of a plant's roots \n      // if it's below LOW_NUTRI, remove the end-most root \n      // and wilt flowers \n      // if root length is below x, start removing plant cells above ground \n      let avg = avgPlant1SoilNutri(i);\n      let {allPlantsPos, avgPlantNutri} = avg;\n      console.log(avgPlantNutri);\n\n      if (avgPlantNutri < LOW_NUTRI) {\n         // let plantX = coordX(soil[i]); \n\n         // look into allPlants to find last root index \n         // remove from allPlants.rootList and soilInfo\n         // start wilting flower\n         if (allPlants[allPlantsPos].rootList.length > 1) {    // so the seed won't be removed \n            let removedID = allPlants[allPlantsPos].rootList.pop();\n            allPlants[allPlantsPos].rootLen -= 1;\n            soilInfo[removedID].state = soilInfo[removedID].state.replace(' root1', '');\n            // soilInfo[removedID].state = soilInfo[removedID].state.replace(' seed1', '');\n            soil[removedID].className = soilInfo[removedID].state;\n            // console.log(`removedID: ${removedID}`)\n            console.log(`${allPlants[allPlantsPos].rootList}`);\n\n            //if (plantInfo[plantX].state.includes('flower1')) {\n               // wiltFlower1(plantX);\n            //}\n         }\n      } \n   }\n   // if soil cell runs out of nutrients\n\n   /* \n   if (soilInfo[i].nutri <= 0) {\n      let stotal = WIDTH * SOIL_HEIGHT;\n      if (i < WIDTH) soilInfo[i].state = 'soil organic';\n      else if (i >= WIDTH && i < stotal / 2 - WIDTH) soilInfo[i].state = 'soil topsoil';\n      else if (i < stotal) soilInfo[i].state = 'soil subsoil';\n\n      // remove cells from allPlants\n      \n      //allPlants[plantID].soilPlantList.pop();\n   }\n   */\n   // let seedID = findSeedID(i);\n   // let allPlantsPos = findIndex(allPlants, seedID); \n   // if length of root >= max root length \n}\n\nfunction wiltFlower1(i) {\n   // change flower1 to flower1_wilted if avg plant nutri lvl < LOW_NUTRI \n   let x = coordX(sky[i]);\n   let y = coordY(sky[i]);\n   let diff = WIDTH * (SKY_HEIGHT - 1);\n   let budID = plantInfo[x].id[SKY_HEIGHT-1];\n   let topSoilID = budID - diff;\n   \n   if (plantInfo[x].state[y] == \"sky flower1\") {\n      let avg = avgPlant1SoilNutri(topSoilID);\n      let {allPlantsPos, avgPlantNutri} = avg;\n\n      // wilt flower\n      if (avgPlantNutri < LOW_NUTRI) {\n         plantInfo[x].state[y] = \"sky flower1_wilted\";\n      }\n      // renew flower\n      else if (plantInfo[x].state[y] == \"sky flower1_wilted\" &&\n      avgPlantNutri >= LOW_NUTRI &&\n      plantInfo[x].state[y+1] == \"sky ab_plant1\") {\n         plantInfo[x].state[y] = \"sky flower1\";\n      }\n   }\n}\n\n\nfunction wiltPlant1(i) {\n   // change ab_plant1 to ab_plant1_wilted \n   // if avg plant nutri lvl < LOW_NUTRI \n   let x = coordX(sky[i]);\n   let y = coordY(sky[i]);\n   let diff = WIDTH * (SKY_HEIGHT - 1);\n   let budID = plantInfo[x].id[SKY_HEIGHT-1];\n   let topSoilID = budID - diff;\n\n   // wilt stem\n   if (plantInfo[x].state[y] == \"sky ab_plant1\") {\n      let avg = avgPlant1SoilNutri(topSoilID);\n      let {allPlantsPos, avgPlantNutri} = avg;\n\n      if (avgPlantNutri < LOW_NUTRI &&\n      plantInfo[x].state[y-1].includes(\"wilted\")) {\n         plantInfo[x].state[y] = \"sky ab_plant1_wilted\";\n      }\n   }\n   // renew stem\n   if (plantInfo[x].state[y] == \"sky ab_plant1_wilted\") {\n      let avg = avgPlant1SoilNutri(topSoilID);\n      let {allPlantsPos, avgPlantNutri} = avg;\n\n      if (avgPlantNutri >= LOW_NUTRI &&\n      plantInfo[x].state[y+1].includes(\"ab_plant1\")) {\n         plantInfo[x].state[y] = \"sky ab_plant1\";\n         //console.log(`plantinfo ${x} state ${y} renewed`);\n      }\n   }\n   \n}\n\nfunction wiltPlant1Bud(i) {\n   // only search through bottom row of sky\n   // change ab_plant1 to ab_plant1_wilted \n   // if avg plant nutri lvl < LOW_NUTRI \n   let x = coordX(sky[i]);\n   let y = coordY(sky[i]);\n   let diff = WIDTH * (SKY_HEIGHT - 1);\n   let budID = plantInfo[x].id[SKY_HEIGHT-1];\n   let topSoilID = budID - diff;\n\n   // wilt bud\n   if (plantInfo[x].state[y] == \"sky ab_plant1\") {\n      let avg = avgPlant1SoilNutri(topSoilID);\n      let {allPlantsPos, avgPlantNutri} = avg;\n\n      if (avgPlantNutri < LOW_NUTRI &&\n         plantInfo[x].state[y-1] == \"sky ab_plant1_wilted\") {\n            plantInfo[x].state[y] = \"sky ab_plant1_wilted\"\n         }\n   }\n   // renew bud \n   if (plantInfo[x].state[y] == \"sky ab_plant1_wilted\") {\n      let avg = avgPlant1SoilNutri(topSoilID);\n      let {allPlantsPos, avgPlantNutri} = avg;\n\n      if (avgPlantNutri >= LOW_NUTRI) {\n         plantInfo[x].state[y] = \"sky ab_plant1\";\n      }\n      /*\n      // remove bud if nutri lvl low and there are no more plants on top\n      if (avgPlantNutri < LOW_NUTRI &&\n      plantInfo[x].state[y-1] == \"sky\") {\n         plantInfo[x].state[y] == \"sky\";\n      } */\n   }\n}\n\nfunction plant1Gone(i) {\n   let diff = WIDTH * (SKY_HEIGHT - 1);  // difference between first row of soil cell and last row of sky cell\n   let x = coordX(sky[i]);\n   let y = coordY(sky[i]);\n\n   if (sky[i].className.includes('flower1_wilted')) {\n      let budID = plantInfo[x].id[SKY_HEIGHT - 1];\n      let topSoilID = budID - diff;\n      let avg = avgPlant1SoilNutri(topSoilID);\n      let {allPlantsPos, avgPlantNutri} = avg;\n\n      let plantCells = plantInfo[x].state.filter(cell => cell.includes('plant'));\n      let wiltedCells = plantInfo[x].state.filter(cell => cell.includes('wilted'));\n\n      // if all plant cells are wilted and nutri lvl is low\n      if (avgPlantNutri < LOW_NUTRI &&\n      plantCells.length + 1 == wiltedCells.length) {\n         for (let j = 0; j < SKY_HEIGHT; j++) {\n            if (!plantInfo[x].state[j].includes('hose')){\n               plantInfo[x].state[j] = 'sky';\n            }\n         }\n      }\n   }\n}\n\nfunction plant1UnderGone(i) {\n   // after plant1 above soil is gone, remove entire plant\n\n   if (soil[i].className.includes('seed1')) {\n      // find x and link to sky\n      let x = coordX(soil[i]);\n      let plant = plantInfo[x].state.filter(cell => cell.includes('ab_plant1'));\n\n      if (plant.length == 0) {\n         let plantID = findIndex(allPlants, i);\n\n         if (allPlants[plantID].soilPlantList.length > 0 &&\n         allPlants[plantID].rootList.length == 1) {\n            for (let j = 0; j < allPlants[plantID].soilPlantList.length; j++) {\n               let udID = allPlants[plantID].soilPlantList[j];\n               soilInfo[udID].state = soilInfo[udID].state.replace(' ud_plant1', '');\n               soil[udID].className = soil[udID].className.replace(' ud_plant1', '');\n            }\n            soilInfo[i].state = soilInfo[i].state.replace(' seed1', '');\n            soil[i].className = soil[i].className.replace(' seed1', '');\n            allPlants.splice(plantID, 1);\n         }\n      }\n   }\n}\n\n\n\nmodule.exports = {\n   allPlants,\n   // skyInfo,\n   // loadSkyInfo,\n   findIndex,\n   toggleSeed1,\n   findSeedID,\n   growRoot1,\n   growPlant1Under,\n   growPlant1Above,\n   seed1Bud,\n   reducePlant1Nutri,\n   wiltFlower1,\n   wiltPlant1,\n   wiltPlant1Bud,\n   plant1Gone,\n   plant1UnderGone\n}\n\n\n\n// figure out localhost \n// make everything slower by just increasing step size \n// design  \n// figure out time thing \n", "// button effects when clicked for restart and garden info \nimport \"./style/main.css\";\n\n\nlet allInfo = document.getElementById('info');\nlet allInfoChildren = allInfo.children;\nconst infoPage = document.getElementById('all_info');\n\n\nfunction initInfo() {\n   // create initial info page that will be shown when browser first opens\n   // hide all info pages except info1 \n   allInfoChildren[0].classname = \"info1\";\n   for (let i = 1; i < allInfoChildren.length; i++) {\n      allInfoChildren[i].className = \"info\" + i + \"_hide\"\n      // console.log(allInfoChildren[i].className);\n   }\n\n}\n\nfunction cycleInfo() {\n   // cycle through info 1-7 \n\n   let currentInfo = 0;\n\n   for (let i = 0; i < allInfoChildren.length; i++) {\n      if (!allInfoChildren[i].className.includes('hide')) {\n         currentInfo = allInfoChildren[i].className;\n      }\n   }\n   // if cycleInfo was previous used, \"refresh it\"\n   if (currentInfo == 0) {\n      allInfoChildren[0].className = 'info1';\n      currentInfo = allInfoChildren[0].className;\n      infoPage.id = \"all_info\";\n   }\n\n   let nextInfoID = Number(currentInfo.replace('info',''));\n   let infoID = Number(currentInfo.replace('info','')) - 1;\n\n   let infoName = infoID + 1;\n   let nextInfoName = nextInfoID + 1;\n\n   // flip to next info \n   if (nextInfoName <= allInfoChildren.length) {\n      allInfoChildren[infoID].className = 'info' + infoName.toString() + '_hide';\n      allInfoChildren[nextInfoID].className = 'info' + nextInfoName.toString();\n   }\n   // at the end of the slide, turn cycle off\n   else if (nextInfoName > allInfoChildren.length) {\n      allInfoChildren[infoID].className = 'info' + infoName.toString() + '_hide';\n      infoPage.id = \"all_info_hide\"\n      // console.log('info cycle ends');\n   }\n  // console.log(`current: ${infoID}, ${allInfoChildren[infoID].className}`);\n  // console.log(nextInfoID);\n  // console.log(currentInfo);\n}\n\nfunction revealRestart() {\n   // click on soil cover enough times to reveal restart button\n}\n\n\n\nmodule.exports = {\n   infoPage,\n   allInfo,\n   allInfoChildren,\n   initInfo,\n   cycleInfo   \n}", "// executes all codes to make the garden alive \n\n\n// =====================\n// sim environment setup\n// =====================\n\nimport \"./style/main.css\";\n\n// not sure why modulle.exports and require() doesn't work / 'TypeError: coordX is not a function'\nimport {coordY, coordX, coordToIndex} from './index-coord-helper.js';\n\n\nlet soilActivities = require('./soil-activities.js');\nlet {\n   soil, \n   soilInfo,\n   mycorInfo,\n   createSoil, \n   loadSoilInfo, \n   createMycor, \n   toggleHRoot, \n   toggleVRoot, \n   mostNutri,\n   growMycor, \n   growVRoot, \n   growHRoot, \n   growHVRoot,\n   reduceNutrient\n} = soilActivities;\n\nlet skyActivies = require('./sky-activities.js');\nlet {\n   sky, \n   plantInfo,\n   createSky, \n   loadPlantInfo, \n   // toggleHPlant, \n   // toggleVPlant, \n   growBud, \n   growPlants,\n   wiltFlower,\n   wiltPlant,\n   plantGone\n} = skyActivies;\n\nlet worldParams = require('./world-params.js');\nlet {WIDTH,\n   SKY_HEIGHT,\n   SOIL_HEIGHT,\n   HEIGHT,\n   LOWEST_STARTING_NUTRI,    // lowest nutri value to be distributed to soil cells \n   LOW_NUTRI,                 // indicating soil has low nutri \n   MAX_NUTRI,                // highest nutri value to be initially distributed \n   ROOT_GROWTH_RATE\n} = worldParams;\n\nlet nutriGrid = require('./nutri-grid.js');\nlet {\n   nutriFrame,\n   soilNutri,\n   soilNutriRec,\n   createSoilNutri,\n   updateNutriRec,\n   showNutri,\n   waterNutriFlow\n} = nutriGrid;\n\nlet hoseActivities = require('./hose.js');\nlet {\n   getSpigots,\n   nextHoseCell,\n   isHose,\n   waterFlow,\n   waterOn,\n   waterBtn\n} = hoseActivities;\n\nlet styling = require('./style-helper.js');\nlet {\n   toggleBtnOnOff,\n   fadeElem\n} = styling;\n\n\nlet plant1 = require('./single-seed.js');\nlet {\n   allPlants,\n   // skyInfo,\n   // loadSkyInfo,\n   findIndex,\n   toggleSeed1,\n   findSeedID,\n   growRoot1,\n   growPlant1Under,\n   growPlant1Above,\n   seed1Bud,\n   reducePlant1Nutri,\n   wiltFlower1,\n   wiltPlant1,\n   wiltPlant1Bud,\n   plant1Gone,\n   plant1UnderGone\n} = plant1;\n\n\nlet page = require('./page-effects.js');\nlet {\n   infoPage,\n   allInfo,\n   allInfoChildren,\n   initInfo,\n   cycleInfo\n} = page;\n\n\nlet allInfo2 = document.getElementById('info');\nconsole.log(allInfo2);\n   /*\n   localStorage.setItem('soil', soil);\n   localStorage.setItem('soilInfo', soilInfo);\n   localStorage.setItem('mycorInfo', mycorInfo);\n\n   localStorage.setItem('sky', sky);\n   localStorage.setItem('plantInfo', plantInfo);\n\n   localStorage.setItem('soilNutri', soilNutri);\n   localStorage.setItem('soilNutriRec', soilNutriRec);\n\n   localStorage.setItem('allPlants', allPlants);\n\n   localStorage.setItem('totalStep', totalStep);\n   \n\n/*\nlocalStorage.setItem('soil', JSON.stringify(soil));\nlocalStorage.setItem('soilInfo', JSON.stringify(soilInfo));\nlocalStorage.setItem('mycorInfo', JSON.stringify(mycorInfo));\n\nlocalStorage.setItem('sky', JSON.stringify(sky));\nlocalStorage.setItem('plantInfo', JSON.stringify(plantInfo));\n\nlocalStorage.setItem('soilNutri', JSON.stringify(soilNutri));\nlocalStorage.setItem('soilNutriRec', JSON.stringify(soilNutriRec));\n\nlocalStorage.setItem('allPlants', JSON.stringify(allPlants));\n\nlocalStorage.setItem('totalStep', totalStep);\n*/\n\n//soil = JSON.parse(localStorage.getItem('soil'))\n\n\n\n// offset step time\nlet totalStep = 0;\nlet mycorGrowthRate = 3;\nlet hRootGrowthRate = 2;\n\n\n\n\n//const waterBtn1 = document.getElementById('activate_water');\n//const waterBtn2 = document.getElementById('water_btn2');\n\nlet timer;\nconst playBtn = document.getElementById('grow_btn');\nconst pauseBtn = document.getElementById('pause');\nconst nextBtn = document.getElementById('next');\nconst reBtn = document.getElementById('restart_btn');\n\nconst hSeedBtn = document.getElementById('h_seed_btn');\nconst vSeedBtn = document.getElementById('v_seed_btn');\nconst nutriBtn = document.getElementById('nutri_btn');\n\nconst singleSeedBtn = document.getElementById('plant1_btn');\n\nconst gardenInfoBtn = document.getElementById('info_btn');\n\n\n\n\n\n// ========\n// stepping\n// ========\n\n// make roots constantly reduce nutrients in soil \n\nlet prevDateTime = new Date();\nlet prevMonth = prevDateTime.getMonth();\nlet prevDay = prevDateTime.getDate();   // returns number\nlet prevHr = prevDateTime.getHours();\nlet prevMin = prevDateTime.getMinutes();\nlet prevSec = prevDateTime.getSeconds();\n\n/*\nlet currMonth = dateTime.getMonth();\nlet currDay = dateTime.getDate();\nlet currHr = dateTime.getHours();\nlet currMin = dateTime.getMinutes();\nlet currSec = dateTime.getSeconds();\n*/\n\n// if currMin - prevMin == some value, growRoot , prevMin = currMin \n\n// roots grow 1 cell every hour \n\nfunction timePassed(prevDate, currDate) {\n   // takes in 2 new Date() variables from different times to calculate \n   // amount of time passed \n   let mSecPassed = currDate - prevDate; \n   let daysPassed = Math.round(mSecPassed / (1000*60*60*24));\n   let hoursPassed = Math.round(mSecPassed / (1000*60*60));\n   let minsPassed = Math.round(mSecPassed / (1000*60));\n   let secsPassed = Math.round(mSecPassed / (1000));\n\n   return {\n      daysPassed: daysPassed,\n      hoursPassed: hoursPassed,\n      minsPassed: minsPassed,\n      secsPassed: secsPassed,\n      mSecPassed: mSecPassed,\n   }\n}\n\n\n\nfunction step() {\n   // iterate through all soil cells and grow roots\n   let currDateTime = new Date();\n   // let currDay = currDateTime.getDate();\n   // let currHr = currDateTime.getHours();\n   // let currMin = currDateTime.getMinutes();\n\n   let timeElapsed = timePassed(prevDateTime, currDateTime);\n   let {daysPassed, hoursPassed, minsPassed, secsPassed, mSecPassed} = timeElapsed;\n\n   // everything for updating soilInfo, plantInfo, and mycorInfo -- slow moving stuff \n   if (minsPassed >= ROOT_GROWTH_RATE) {\n      for (let i = 0; i < soil.length; i++) {\n         if (soil[i].className.includes('h_root')) { growHRoot(i); }\n   \n         else if (soil[i].className.includes('v_root')) growVRoot(i);\n   \n         else if (soil[i].className.includes('mycor')\n         /* && totalStep % mycorGrowthRate == 0 */) { growMycor(i); }\n   \n   \n         if (soil[i].className.includes('seed1') ||\n         soil[i].className.includes('ud_plant1')) { growPlant1Under(i); }\n   \n         if (soil[i].className.includes('seed1') || \n         soil[i].className.includes('root1')) { growRoot1(i); }\n         // else { continue }\n         reduceNutrient(i);\n         reducePlant1Nutri(i);\n         plant1UnderGone(i);\n      }\n      // iterate through sky cells and grow buds and plants   \n      // and drop water if hose is turned on \n      for (let k = sky.length - WIDTH - 1; k > 0; k--) {\n         growPlants(k);\n         growPlant1Above(k);\n         // waterFlow(k);\n      } \n      for (let j = sky.length - WIDTH; j < sky.length; j++) {\n         growBud(j);\n         seed1Bud(j);\n         wiltPlant1Bud(j);\n         // waterFlow(j);\n      }\n      for (let l = 0; l < sky.length - WIDTH; l++) {\n         wiltFlower(l);\n         wiltPlant(l);\n         plantGone(l);\n   \n         wiltFlower1(l);\n         wiltPlant1(l);\n         plant1Gone(l);\n      }\n      // update prevDateTime to currDateTime\n      prevDateTime = currDateTime;\n   }\n\n   // update display cells, water flow, nutri water flow \n   // moves at the speed of step size\n   for (let k = 0; k < sky.length; k++) {\n      waterFlow(k);\n   } \n   // water in nutri grid\n   if (waterBtn.className == 'toggled') { waterOn(); }  // the hose takes a while to turn off\n   waterNutriFlow();\n   updateNutriRec();\n\n   // update soil grid and nutri grid, make changes visible\n   for (let i = 0; i < soil.length; i++) {\n      soil[i].className = soilInfo[i].state;\n      soilNutri[i].className = soilNutriRec[i];\n      if (mycorInfo.includes(soilInfo[i].organism)) {\n         soil[i].className = soil[i].className.concat(' mycor');\n      }\n   }\n   // cleanMycorInfo();\n\n   // update sky\n   for (let i = 0; i < sky.length; i++) {\n      //wiltFlower(i);\n      let x = coordX(sky[i]);\n      let y = coordY(sky[i]);\n      sky[i].className = plantInfo[x].state[y]; \n   }\n   // don't update prevDateTime\n   \n   console.log(`days: ${daysPassed}, hours: ${hoursPassed}, mins: ${minsPassed}, \n   secs: ${secsPassed}, msecs: ${mSecPassed} `)\n   // totalStep += 1;\n   \n   /*\n   // localStorage.setItem('soil', JSON.stringify(soil));\n   localStorage.setItem('soilInfo', JSON.stringify(soilInfo));\n   localStorage.setItem('mycorInfo', JSON.stringify(mycorInfo));\n\n   // localStorage.setItem('sky', JSON.stringify(sky));\n   localStorage.setItem('plantInfo', JSON.stringify(plantInfo));\n\n   localStorage.setItem('soilNutri', JSON.stringify(soilNutri));\n   localStorage.setItem('soilNutriRec', JSON.stringify(soilNutriRec));\n\n   localStorage.setItem('allPlants', JSON.stringify(allPlants));\n\n   localStorage.setItem('totalStep', totalStep);\n   */\n}\n\n \nfunction restart() {\n   localStorage.clear();\n\n   totalStep = 0;\n   \n   for (let i = 0; i < WIDTH; i++) {\n      soil[i].className = 'soil organic';\n      soilInfo[i].state = 'soil organic';\n      soilInfo[i].nutri = Math.floor(Math.random() * (MAX_NUTRI-LOWEST_STARTING_NUTRI) + LOWEST_STARTING_NUTRI);\n   }\n   for (let i = WIDTH; i < soil.length / 2 - WIDTH; i++) {\n      soil[i].className = 'soil topsoil';\n      soilInfo[i].state = 'soil topsoil';\n      soilInfo[i].nutri = Math.floor(Math.random() * (MAX_NUTRI-LOWEST_STARTING_NUTRI) + LOWEST_STARTING_NUTRI);\n   }\n   for (let i = soil.length / 2 - WIDTH; i < soil.length; i++) {\n      soil[i].className = 'soil subsoil';\n      soilInfo[i].state = 'soil subsoil';\n      soilInfo[i].nutri = Math.floor(Math.random() * (MAX_NUTRI-LOWEST_STARTING_NUTRI) + LOWEST_STARTING_NUTRI);\n   }\n   for (let i = 0; i < sky.length; i++) {\n      let x = coordX(sky[i]);\n      let y = coordY(sky[i]);\n      sky[i].className = 'sky';\n      plantInfo[x].state[y] = 'sky';\n   }\n   createMycor();\n   \n   // updates for nutri grid\n   for (let i = 0; i < WIDTH*SOIL_HEIGHT; i++) {\n       soilNutriRec[i] = \"soil-nutri nutri_soil\";\n       soilNutri[i].className = \"soil-nutri nutri_soil\";\n\n      if (soilInfo[i].nutri < LOW_NUTRI &&\n      !soilNutriRec[i].includes('low-nutri')) {\n         soilNutri[i].className = soilNutri[i].className.concat(' low-nutri');\n         soilNutriRec[i]= soilNutriRec[i].concat(' low-nutri');\n      }\n      if (soilInfo[i].nutri >= LOW_NUTRI && \n      soilInfo[i].nutri < LOWEST_STARTING_NUTRI + 2 &&\n      !soilNutriRec[i].includes('med-nutri')) {\n         soilNutriRec[i] = soilNutriRec[i].concat(' med-nutri');\n         soilNutri[i].className = soilNutri[i].className.concat(' med-nutri');\n      }\n      if (soilInfo[i].nutri > MAX_NUTRI) {\n         soilNutriRec[i] = soilNutriRec[i].replace('low-nutri', '');\n         soilNutriRec[i] = soilNutriRec[i].replace('med-nutri', '');\n         soilNutri[i] = soilNutri[i].replace('low-nutri', '');\n         soilNutri[i] = soilNutri[i].replace('med-nutri', '');\n      }\n      if (soilInfo[i].nutri <= 0 &&\n      !soilNutriRec[i].includes('dead-nutri')) {\n         soilNutriRec[i] = soilNutriRec[i].concat(' dead-nutri');\n         soilNutri[i].className = soilNutri[i].className.concat(' dead-nutri');\n      }\n    }\n\n   allPlants = [];\n}\n\n\nfunction stepFast() {\n   // iterate through all soil cells and grow roots\n   // without using dateTime\n   for (let i = 0; i < soil.length; i++) {\n      if (soil[i].className.includes('h_root') && \n      totalStep % hRootGrowthRate == 0 ) { growHRoot(i); }\n\n      else if (soil[i].className.includes('v_root')) growVRoot(i);\n\n      else if (soil[i].className.includes('mycor')\n      /* && totalStep % mycorGrowthRate == 0 */) { growMycor(i); }\n\n\n      if (soil[i].className.includes('seed1') ||\n      soil[i].className.includes('ud_plant1')) { growPlant1Under(i); }\n\n      if (soil[i].className.includes('seed1') || \n      soil[i].className.includes('root1')) { growRoot1(i); }\n      // else { continue }\n      reduceNutrient(i);\n      reducePlant1Nutri(i);\n      plant1UnderGone(i);\n   }\n\n   // iterate through sky cells and grow buds and plants   \n   // and drop water if hose is turned on \n   // why do I have 3 for loops here again??? \n   for (let k = sky.length - WIDTH - 1; k > 0; k--) {\n      growPlants(k);\n      growPlant1Above(k);\n      waterFlow(k);\n   } \n   for (let j = sky.length - WIDTH; j < sky.length; j++) {\n      growBud(j);\n      seed1Bud(j);\n      wiltPlant1Bud(j);\n      waterFlow(j);\n   }\n   for (let l = 0; l < sky.length - WIDTH; l++) {\n      wiltFlower(l);\n      wiltPlant(l);\n      plantGone(l);\n\n      wiltFlower1(l);\n      wiltPlant1(l);\n      plant1Gone(l);\n   }\n\n   // water in nutri grid\n   if (waterBtn.className == 'toggled') { waterOn(); }  // the hose takes a while to turn off\n   waterNutriFlow();\n   updateNutriRec();\n\n   // update soil grid and nutri grid, make changes visible\n   for (let i = 0; i < soil.length; i++) {\n      soil[i].className = soilInfo[i].state;\n      soilNutri[i].className = soilNutriRec[i];\n      if (mycorInfo.includes(soilInfo[i].organism)) {\n         soil[i].className = soil[i].className.concat(' mycor');\n      }\n   }\n   // cleanMycorInfo();\n\n   // update sky\n   for (let i = 0; i < sky.length; i++) {\n      //wiltFlower(i);\n      let x = coordX(sky[i]);\n      let y = coordY(sky[i]);\n      sky[i].className = plantInfo[x].state[y]; \n   }\n   totalStep += 1;\n   \n   /*\n   // localStorage.setItem('soil', JSON.stringify(soil));\n   localStorage.setItem('soilInfo', JSON.stringify(soilInfo));\n   localStorage.setItem('mycorInfo', JSON.stringify(mycorInfo));\n\n   // localStorage.setItem('sky', JSON.stringify(sky));\n   localStorage.setItem('plantInfo', JSON.stringify(plantInfo));\n\n   localStorage.setItem('soilNutri', JSON.stringify(soilNutri));\n   localStorage.setItem('soilNutriRec', JSON.stringify(soilNutriRec));\n\n   localStorage.setItem('allPlants', JSON.stringify(allPlants));\n\n   localStorage.setItem('totalStep', totalStep);\n   */\n}\n\n\n\n// =============\n// initiate sim\n// =============\n\ninitInfo();\n\ncreateSky();\ncreateSoil();\n// loadSkyInfo();\nloadSoilInfo();\nloadPlantInfo();\n\ncreateMycor();\n\ncreateSoilNutri();\nupdateNutriRec();\n\n// update soilNutri\nfor (let i = 0; i < soil.length; i++) {\n   soilNutri[i].className = soilNutriRec[i];\n}\n\n// click on a sky cell to turn it to h plant / v plant / hose \n/* sky.forEach((cell) => { toggleHose(cell) }); */\n\n/*\nsky.forEach((cell) => { toggleHPlant(cell)});\nsky.forEach((cell) => { toggleVPlant(cell) });\n*/\n\n\n//// localStorage.setItem('soil', JSON.stringify(soil));\n// localStorage.setItem('soilInfo', JSON.stringify(soilInfo));\n// localStorage.setItem('mycorInfo', JSON.stringify(mycorInfo));\n\n//// localStorage.setItem('sky', JSON.stringify(sky));\n// localStorage.setItem('plantInfo', JSON.stringify(plantInfo));\n\n//// localStorage.setItem('soilNutri', JSON.stringify(soilNutri));\n// localStorage.setItem('soilNutriRec', JSON.stringify(soilNutriRec));\n\n// localStorage.setItem('allPlants', JSON.stringify(allPlants));\n\n// localStorage.setItem('totalStep', totalStep);\n\n\n/*\n// localStorage.setItem('soil', soil);\nlocalStorage.setItem('soilInfo', soilInfo);\nlocalStorage.setItem('mycorInfo', mycorInfo);\n\nlocalStorage.setItem('sky', sky);\nlocalStorage.setItem('plantInfo', plantInfo);\n\nlocalStorage.setItem('soilNutri', soilNutri);\nlocalStorage.setItem('soilNutriRec', soilNutriRec);\n\nlocalStorage.setItem('allPlants', allPlants);\n\nlocalStorage.setItem('totalStep', totalStep);\n*/\n\n// soil = localStorage.getItem('soil');\n// soil = JSON.parse(localStorage.getItem('soil'));\n\n/*\nsoilInfo = JSON.parse(localStorage.getItem('soilInfo'));\nmycorInfo = JSON.parse(localStorage.getItem('mycorInfo'));\n\nplantInfo = JSON.parse(localStorage.getItem('plantInfo'));\n\nsoilNutri = JSON.parse(localStorage.getItem('soilNutri'));\nsoilNutriRec = JSON.parse(localStorage.getItem('soilNutriRec'));\n\nallPlants = JSON.parse(localStorage.getItem('allPlants'));\n\ntotalStep = JSON.parse(localStorage.getItem('totalStep'));\n*/\n\n\n\n// ===========================\n// assign functions to buttons\n// ===========================\n\n/*\nhSeedBtn.addEventListener('click', function() {\n   soil.forEach((cell) => { toggleHRoot(cell) });\n   toggleBtnOnOff(hSeedBtn);\n});\n\nvSeedBtn.addEventListener('click', function() {\n   soil.forEach((cell) => { toggleVRoot(cell) });\n   toggleBtnOnOff(vSeedBtn);\n});\n*/\n\nnutriBtn.addEventListener('click', function() {\n   showNutri();\n   toggleBtnOnOff(nutriBtn);\n});\n\nsingleSeedBtn.addEventListener('click', function() {\n   soil.forEach((cell) => { toggleSeed1(cell) });\n   toggleBtnOnOff(singleSeedBtn);\n});\n\n\n\n\n\nplayBtn.addEventListener('click', function() {\n   if (playBtn.className !== 'toggled') {\n      toggleBtnOnOff(playBtn);\n      fadeElem(playBtn, 900, '0.15');\n      timer = setInterval(step, 300);\n   }\n    });\n   // need to prevent player from executing 'play' more than once \n\n// pauseBtn.addEventListener('click', function() {clearInterval(timer);});\n\n// nextBtn.addEventListener('click', step);\n\nreBtn.addEventListener('click', function() {\n   toggleBtnOnOff(reBtn);\n   clearInterval(timer);\n   restart();\n});\n\ngardenInfoBtn.addEventListener('click', function() {\n   // toggleBtnOnOff(gardenInfoBtn);\n   cycleInfo();\n})\n\n//reBtn.addEventListener('click', restart);\n\ninfoPage.addEventListener('click', function() {\n   cycleInfo();\n   // console.log('allInfo page clicked')\n})\n\n\n\n\n\n\n//waterBtn2.addEventListener('click', getSpigots);\n\n//waterBtn1.addEventListener('change', getSpigots); \n//getSpigots()\n\n\n\n// would be nice if game automatically starts after the first seed is planted "],
  "mappings": "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",
  "names": []
}
